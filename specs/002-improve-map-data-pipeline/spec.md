# 機能仕様書: 地図データパイプラインの改善

**フィーチャーブランチ**: `002-improve-map-data-pipeline`
**作成日**: 2026-02-13
**ステータス**: Draft
**入力**: ユーザー説明: "地図データ作成周りの課題を洗い出して改善したい"

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー 1 - データ変換の自動化 (優先度: P1)

開発者として、ソースGeoJSONファイルからデプロイ可能なマップタイルへの変換を単一のコマンドで実行したい。これにより、複数のスクリプトを順番に手動実行する必要がなくなり、人的ミスのリスクを軽減できる。

現在のデータパイプラインでは、手動でのGeoJSONダウンロードの後に `convert-to-pmtiles.sh`、`prepare-pmtiles.mjs`、`upload-to-r2.sh` を順番に実行する必要がある。各スクリプトは前のステップへの暗黙的な依存関係を持ち、途中で失敗した場合は手動での介入が必要になる。

**この優先度の理由**: 手動の多段階プロセスが最大のボトルネックである。データ更新のたびに、開発者は壊れやすいコマンドの順序を正しく記憶して実行する必要がある。最もインパクトの大きい改善点。

**独立テスト**: サンプルGeoJSONファイルに対して単一コマンドを実行し、期待する出力先に有効なマップタイルが生成されることを検証すれば完全にテスト可能。

**受け入れシナリオ**:

1. **前提** ソースGeoJSONファイルが利用可能な状態で、**操作** 開発者が統合パイプラインコマンドを実行した場合、**結果** 正しいレイヤー（territories と labels）を持つマップタイルが生成され、出力ディレクトリに配置される。
2. **前提** パイプラインが実行中の状態で、**操作** ある変換ステップが失敗した場合、**結果** パイプラインが停止し、どのステップがなぜ失敗したかを報告し、不完全な出力を生成しない。
3. **前提** パイプラインが以前に実行されたことがある状態で、**操作** 一部のソースファイルのみが変更された場合、**結果** 変更されたファイルのみが再処理される（差分処理）。

---

### ユーザーストーリー 2 - データバリデーション (優先度: P2)

開発者として、パイプラインが各段階でデータを自動的に検証してほしい。これにより、デプロイ済みアプリケーションに問題が到達する前に早期発見できる。

現在、ポリゴンマージステップ後の自動バリデーションは存在しない。壊れた・不正なGeoJSON、欠落した属性（`NAME`、`SUBJECTO`）、空のフィーチャーコレクションが、パイプラインを通じて静かに伝播する可能性がある。

**この優先度の理由**: バリデーションなしでは、壊れたデータが気づかれないまま本番にデプロイされる可能性がある。バリデーションはデータの整合性を保護し、早期に問題を発見することでデバッグ時間を削減する。

**独立テスト**: 有効なGeoJSONファイルと意図的に不正なGeoJSONファイルの両方を提供し、バリデーションが正しく問題を特定することを検証すれば完全にテスト可能。

**受け入れシナリオ**:

1. **前提** 有効なGeoJSONファイルがある状態で、**操作** バリデーションが実行された場合、**結果** エラーなしで合格する。
2. **前提** 必須属性が欠落したGeoJSONファイル（例: `NAME` プロパティの欠落）がある状態で、**操作** バリデーションが実行された場合、**結果** 具体的な欠落属性と影響を受けるフィーチャーを報告する。
3. **前提** ポリゴンマージの結果がゼロフィーチャーとなるGeoJSONファイルがある状態で、**操作** バリデーションが実行された場合、**結果** マージの結果が空であることを示すエラーが発生する。
4. **前提** すべてのデータがバリデーションに合格した状態で、**操作** パイプラインが完了した場合、**結果** 年度ごとのフィーチャー数と警告を含むバリデーションサマリーレポートが生成される。

---

### ユーザーストーリー 3 - 差分デプロイ (優先度: P3)

開発者として、変更されたマップタイルのみがデプロイ時にアップロードされるようにしたい。これにより、デプロイ時間と帯域幅の使用を削減できる。

現在、`upload-to-r2.sh` はほとんどのファイルが変更されていなくても、毎回すべてのファイルをストレージバケットにアップロードする。54ファイル、527MBのPMTilesデータに対して、これは無駄である。

**この優先度の理由**: デプロイ時間と帯域幅コストを削減する。正確性の問題ではないが、頻繁なデータ更新における開発者体験を大幅に改善する。

**独立テスト**: 1ファイルを変更した後にデプロイを実行し、そのファイルのみがアップロードされることを検証すれば完全にテスト可能。

**受け入れシナリオ**:

1. **前提** 以前のデプロイが存在する状態で、**操作** 54ファイル中3ファイルが変更された場合、**結果** その3ファイルのみがアップロードされる。
2. **前提** 完全に新しいデプロイの状態で、**操作** 以前のデプロイが存在しない場合、**結果** すべてのファイルがアップロードされる。
3. **前提** デプロイが完了した状態で、**操作** 開発者がデプロイログを確認した場合、**結果** どのファイルがアップロードされ、どのファイルがスキップされたかが表示される。

---

### ユーザーストーリー 4 - 年代インデックスの自動生成 (優先度: P3)

開発者として、マップタイルデータが変更されるたびに年代インデックス（利用可能な年代とその領土の一覧）が自動的に再生成されるようにしたい。これにより、インデックスが実際のデータと常に一致する。

現在、`generate-index.sh` は手動で実行する必要があり、その出力は実際のPMTilesコンテンツと乖離する可能性がある。

**この優先度の理由**: データの一貫性は重要だが、インデックスはメインデータの派生物であるため、パイプラインの一部として自動生成することはデータの乖離を防ぐ自然な拡張である。

**独立テスト**: パイプラインを実行し、生成されたインデックスと実際に存在するPMTilesファイルを比較すれば完全にテスト可能。

**受け入れシナリオ**:

1. **前提** 1600年、1650年、1700年のマップタイルが存在する状態で、**操作** インデックスが生成された場合、**結果** インデックスにはその3年分のエントリが正しいファイル名と領土リスト付きで含まれる。
2. **前提** 新しい年（1750年）が追加された状態で、**操作** パイプラインが実行された場合、**結果** インデックスが自動的に更新され新しい年が含まれる。
3. **前提** ある年が削除された状態で、**操作** パイプラインが実行された場合、**結果** インデックスからその年が除外される。

---

### エッジケース

- フェッチステージで上流 historical-basemaps リポジトリに到達できない場合 → パイプラインはエラーを報告して停止する。ローカルキャッシュが存在する場合はオフラインモードで続行可能とする。
- GeoJSONファイルに自己交差や無効なジオメトリを持つポリゴンが含まれている場合 → 自動修復（buffer(0) 等）を試み、修復不可なフィーチャーはエラーとして拒否し、バリデーションレポートに記録する。
- 変換中にディスク容量が不足した場合はどうなるか（既存タイル527MBを考慮して）？
- 開発者がパイプラインを同時に実行した場合はどうなるか（例: 2つのターミナルセッション）？
- ある年に領土がない場合はどうなるか（空のフィーチャーコレクション）？

## Clarifications

### Session 2026-02-13

- Q: パイプラインの実装技術は？ → A: Node.js (TypeScript) - 既存の prepare-pmtiles.mjs を拡張し、shell スクリプトの処理も TypeScript に統合する。
- Q: パイプライン失敗時のリカバリ戦略は？ → A: チェックポイント再開 - 各ステージ完了をマークし、失敗時は最後の成功ステージから再開できるようにする。
- Q: 無効なジオメトリの処理方針は？ → A: 自動修復 + フォールバック拒否 - buffer(0) 等で自動修復を試み、修復不可なら拒否して警告する。
- Q: 変更検出メカニズムは？ → A: コンテンツハッシュ (SHA-256) - ファイル内容のハッシュ値で変更を検出する。デプロイメントマニフェストと一貫性あり。
- Q: ソースデータの取得方法は？ → A: パイプラインに統合 - git clone/pull で上流リポジトリから自動取得をパイプラインの最初のステージとして含む。

## 要件 *(必須)*

### 機能要件

- **FR-001**: パイプラインは、すべてのステージ（フェッチ（git clone/pull）、マージ、バリデーション、変換、準備、アップロード、インデックス生成）を正しい順序で実行する単一のエントリポイントコマンドを提供しなければならない。ソースデータの取得（historical-basemaps リポジトリからの git clone/pull）をパイプラインの最初のステージとして含む。
- **FR-002**: パイプラインは、コンテンツハッシュ（SHA-256）を使用して前回の実行以降に変更されたソースファイルを検出し、それらのファイルのみを再処理しなければならない。ハッシュ値はパイプライン状態ファイルに永続化する。
- **FR-003**: パイプラインは、マージステップ後にGeoJSONデータを検証しなければならない。検証内容: 必須属性（`NAME`）、空でないフィーチャーコレクション、有効なジオメトリタイプ。無効なジオメトリに対しては自動修復（buffer(0) 等）を試み、修復不可なフィーチャーはエラーとして拒否する。
- **FR-004**: パイプラインは、バリデーション失敗時に実行を停止してエラーを報告し、無効なデータが後続のステージに進むことを防がなければならない。
- **FR-005**: パイプラインは、実行ごとにバリデーションサマリーを生成しなければならない。内容: 年度ごとの統計（フィーチャー数、領土数、警告）。
- **FR-006**: パイプラインは、パイプライン実行の一部として年代インデックスを自動生成し、実際のタイルデータとの一貫性を確保しなければならない。
- **FR-007**: パイプラインは、デバッグおよび開発目的で個別のステージを独立して実行すること（例: 「バリデーションのみ」「アップロードのみ」）をサポートしなければならない。
- **FR-008**: パイプラインは、アップロード前にローカルのタイルコンテンツハッシュ（SHA-256）とデプロイメントマニフェストに記録されたリモートの状態を比較し、差分のあるファイルのみをアップロードしなければならない。
- **FR-009**: パイプラインは、データ破損を防ぐために同時実行を防止しなければならない。
- **FR-010**: パイプラインは、各ステージの進行状況とタイミングをログに記録し、デバッグのための明確な実行トレースを提供しなければならない。
- **FR-012**: パイプラインは、各ステージ完了時にチェックポイントを記録し、失敗後に最後の成功ステージから自動的に再開できなければならない。`--restart` フラグで強制的にクリーンリスタートも可能とする。
- **FR-011**: パイプラインは、全年度の処理に加えて、単一の年度または年度範囲の処理をサポートしなければならない。スコープは上流データソース（historical-basemaps リポジトリ）で利用可能な年度に限定される。

### 主要エンティティ

- **ソースデータ**: 特定の年の歴史的な領土境界を表す生のGeoJSONファイル。`NAME`、`SUBJECTO`、`PARTOF`、`BORDERPRECISION` などの属性を持つポリゴンを含む。
- **マージ済みデータ**: 同名の領土がMultiPolygonに結合された処理済みGeoJSON。ラベルポイント（重心）が別レイヤーとして生成される。
- **マップタイル**: PMTiles形式のバイナリタイルファイル。2つのレイヤー（ポリゴン塗りつぶし用のterritories、重心ポイント用のlabels）を含み、Web配信に最適化されている。
- **年代インデックス**: 利用可能なすべての年代、対応するタイルファイル名、各年に存在する領土の構造化されたリスト。
- **デプロイメントマニフェスト**: 年度識別子からコンテンツハッシュ付きタイルファイル名へのマッピング。本番環境でのキャッシュ無効化に使用。
- **バリデーションレポート**: 実行ごとのデータ品質チェックのサマリー。フィーチャー数、属性の完全性、警告やエラーを含む。

## 成功基準 *(必須)*

### 測定可能な成果

- **SC-001**: 開発者が単一年度のマップデータを5分以内で更新できる（コマンド実行からデプロイまでのエンドツーエンド）。現在の手動多段階プロセスと比較。
- **SC-002**: デプロイされたタイルデータの100%がすべてのバリデーションチェックに合格する（属性欠落なし、空のフィーチャーコレクションなし、有効なジオメトリ）。
- **SC-003**: 差分デプロイにより変更されたファイルのみがアップロードされ、一般的な単一年度更新でデプロイのデータ転送量が少なくとも80%削減される。
- **SC-004**: 年代インデックスがデプロイ済みタイルデータと常に一致する（インデックスとデータの乖離がゼロ）。
- **SC-005**: パイプラインの失敗が、具体的なステージ、ファイル、失敗の性質を特定する実用的なエラーメッセージを生成する。
- **SC-006**: 新しいコントリビューターが、ドキュメント化されたセットアップ手順に従って、新規開発環境で完全なパイプラインを正常に実行できる。

### 技術的制約

- **TC-001**: パイプラインは Node.js (TypeScript) で実装する。既存の `prepare-pmtiles.mjs` を拡張し、現在 shell スクリプトで実行している処理（`convert-to-pmtiles.sh`、`upload-to-r2.sh` 等）も TypeScript に統合する。
- **TC-002**: パイプラインは pnpm スクリプトとして実行可能とする（例: `pnpm pipeline` または `pnpm pipeline:run`）。

## 前提条件

- 上流データソース（historical-basemaps GitHubリポジトリ）が現在の形式でGeoJSONファイルを提供し続ける。
- 2つのレイヤー（territories と labels）を持つ現在のPMTiles形式がターゲット出力形式として維持される。
- 本番デプロイメントの既存のコンテンツハッシュベースのキャッシュ戦略が維持される。
- 開発者がシステムレベルの依存関係をインストールするアクセス権を持っている（例: macOSでのHomebrew経由）。
- Cloudflare R2 + Worker のデプロイアーキテクチャはこの機能の一部として変更されない。
