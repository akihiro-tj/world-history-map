# リサーチ: 領土情報パネル リデザイン

**ブランチ**: `004-territory-info-redesign` | **日付**: 2026-03-01

## 1. Notion から JSON へのデータ同期パイプライン

### 決定: Notion API (`@notionhq/client`) + Notion MCP（データ投入）

**根拠**: マスターデータの読み書きを一貫した方法で行える。AI が Notion MCP でデータを直接投入し、人が Notion 上でレビュー・編集し、パイプラインが Notion API でデータを取得して JSON に変換する。

**検討した代替案**:

| アプローチ | セットアップコスト | 依存関係 | 判定 |
|-----------|----------------|---------|------|
| Google Sheets CSV エクスポート | ゼロ（読み取りのみ） | `csv-parse` | 書き込み方向が未解決（手動インポート必要） |
| Google Sheets API v4 | 高（GCP プロジェクト必須） | `googleapis`（重い） | 開発ツールには過剰 |
| **Notion API + Notion MCP** | **低（Integration 作成のみ）** | **`@notionhq/client`** | **採用: 読み書き両方が自然なフロー** |
| JSON 直接生成 | ゼロ | なし | 継続的メンテナンスの仕組みがない |

**実装方針**:
- `@notionhq/client` で Notion データベースからページを取得
- Notion Integration トークンは 1Password（`op read` コマンド）で管理
- 既存の `apps/pipeline/src/cli.ts` に `sync-descriptions` サブコマンドとして追加
- Notion データベース ID は `apps/pipeline/src/config.ts` に定数として格納
- AI によるデータ投入は Notion MCP 経由（パイプラインコードでは読み取りのみ）

### Notion データベース構造

**決定**: 単一データベースに year プロパティを持つフラット構造

**根拠**: 領土-年エントリごとに 1 ページ。パイプライン側で year プロパティに基づいてグルーピングし、年別 JSON ファイルに変換する。

**データベースプロパティ**（領土-年エントリごとに 1 ページ）:

| プロパティ | フィールド | 型 | 備考 |
|-----------|---------|------|------|
| year | 年 | Number | 負数は紀元前 |
| territory_id | 領土キー | Rich text | kebab-case、GeoJSON NAME と一致 |
| name | 表示名 | Title | 日本語 |
| era | 時代ラベル | Rich text | オプション、不明なら空欄 |
| capital | 首都 | Rich text | オプション |
| regime | 政体 | Rich text | オプション |
| leader | 指導者 | Rich text | オプション |
| dynasty | 王朝 | Rich text | オプション、領土名≈王朝名の場合は空欄 |
| religion | 宗教 | Rich text | オプション |
| context | 文脈記述 | Rich text | 2〜3 文、100〜200 字 |
| key_events | タイムラインイベント | Rich text | `年:説明` のペア、`\|` 区切り |

**key_events のエンコード**: `1581:独立宣言の説明|1602:東インド会社設立の説明` -- `|` で分割後、最初の `:` で年とイベントテキストに分割。

**同期時のバリデーション**: "不明" を含むプロパティはエラーとして拒否。代わりにフィールドを JSON から省略する。

## 2. データモデル設計

### 決定: オプションフィールドを持つ構造化プロフィール、冗長なメタデータを削除

**根拠**: 名前付きキー・バリューフィールドが非構造化の `facts: string[]` を置き換える。フィールドは TypeScript レベルでオプション型 -- データがない場合はフィールドの省略で表現し、"不明" 値は使わない。

**現行モデルからの主な変更点**:

| フィールド | 現行 | 新規 | 理由 |
|-----------|------|------|------|
| `id` | `"France_1700"` | 削除 | 冗長（バンドルキー + ファイル名で導出可能） |
| `year` | `1700` | 削除 | ファイル名から導出可能 |
| `facts` | `string[]` | `profile?: TerritoryProfile` | 構造化キー・バリューペア |
| `era` | なし | `era?: string` | 新規: 歴史的時代ラベル |
| `context` | なし | `context?: string` | 新規: 時間的文脈テキスト |
| `aiGenerated` | `true`（リテラル） | 削除 | すべてのデータが AI 生成。UI は無条件に注意書きを表示 |
| `keyEvents` | `KeyEvent[]` | `keyEvents?: KeyEvent[]` | オプション化。空の場合は省略 |

**プロフィールフィールドの表示順序**（全領土で一貫）: 首都 → 政体 → 王朝 → 指導者 → 宗教

**時間的分類**: 表示時に `selectedYear` との比較で算出。データには保存しない。
- `event.year < selectedYear` → `"past"`（過去）
- `event.year === selectedYear` → `"current"`（現在: 完全一致のみ、仕様の Clarification に基づく）
- `event.year > selectedYear` → `"future"`（未来）

### ファイル構造の維持

**決定**: `{year}.json` + `Record<string, TerritoryDescription>` フォーマットを維持

**根拠**: 年単位のバンドリングにより、指定年のすべての領土を 1 回の fetch で取得可能。`use-territory-description.ts` の既存プリフェッチ/キャッシュロジックがそのまま動作する。目標 50〜70 領土 × 50 年ファイルでバンドルサイズは管理可能。

### バリデーション戦略

**決定**: パイプライン側に Zod スキーマ、フロントエンド側は TypeScript インターフェース

**根拠**: フロントエンドに Zod 依存を持ち込まない。パイプラインが同期時に Zod スキーマでデータを検証し "不明" ルールを強制する。CI は `pnpm check` の一部としてバリデーションを実行する。

**バリデーションルール**:

| フィールド | ルール |
|-----------|--------|
| `name` | 必須、非空、"不明" 禁止 |
| `era` | 存在する場合: 非空、"不明" 禁止 |
| `profile.*` | 存在する場合: 非空、"不明" 禁止。データがなければフィールド自体を省略 |
| `context` | 存在する場合: 50〜200 字 |
| `keyEvents[].event` | 存在する場合: 非空、"不明" 禁止 |

## 3. タイムライン UI 設計

### 決定: 三段階の視覚的区別を持つ縦型タイムライン

**視覚パターン**:

| 状態 | マーカー | ライン | テキスト | 背景 |
|------|---------|--------|---------|------|
| 過去 | 塗りつぶし円 | 実線（薄い） | `text-slate-500`, `opacity-75` | なし |
| 現在 | リング + 強調 | 実線（太い） | フルカラー、`font-semibold` | 薄いハイライト |
| 未来 | 中空円 | 破線 | `text-slate-400`, `opacity-60` | なし |

**選択年マーカー**: 選択年に完全一致するイベントがない場合、正しい時系列位置にゴーストマーカー（`role="separator"`）を挿入し、年ラベルを表示。ダイヤモンドアイコンと水平線を使用。

**アクセシビリティ（WCAG 2.1 AA）**:
- セマンティックマークアップ: `<ol aria-label="...">` + 現在イベントに `<li aria-current="true">`
- 複合的な手がかりによる区別: アイコン形状 + ボーダースタイル + テキストウェイト（色のみに依存しない）
- タッチターゲット: モバイルで最低 44x44px
- スクリーンリーダー: 現在イベントに `aria-current="true"`、年マーカーに `role="separator"` + `aria-label`

**モバイル対応**:
- デスクトップパネルとボトムシートで共通の縦型レイアウト
- モバイルでマーカーを大きく表示（16px vs 12px）
- 年変更時に `scrollIntoView` で選択年マーカーを中央表示

### 検討した代替案

| パターン | 判定 |
|---------|------|
| 水平タイムライン | 却下: モバイル体験が悪い、表示できるイベント数が限られる |
| 2 カラム（過去左、未来右） | 却下: レイアウトが複雑、イベント少数時に不明瞭 |
| **単一縦型、左揃え** | **採用**: パネルとボトムシート両方で動作 |
| アコーディオン/折りたたみ | 却下: インタラクションコストが増加、約 10 イベントには不要 |

## 4. コンスティチューション準拠に関する補足

### 原則 I（テストファースト）
- データバリデーションスキーマにユニットテスト
- タイムライン分類ロジックにユニットテスト
- 新規 UI コンポーネントにコンポーネントテスト（Vitest + Testing Library）
- パネル表示の E2E テスト（Playwright）

### 原則 II（シンプルさと型安全性）
- `any` 型なし。すべての新規インターフェースは strict なオプションフィールドを使用
- Notion API（公式 SDK `@notionhq/client`）による読み取り + Notion MCP による書き込み
- 抽象化レイヤーなし -- 直接 query + transform + write

### 原則 III（コンポーネント駆動とアクセシビリティ）
- タイムラインコンポーネントは `ClassifiedKeyEvent[]` 入力で再利用可能
- WCAG 2.1 AA: セマンティック HTML、ARIA 属性、複合的な視覚的区別
- タイムラインアイテムのキーボードナビゲーション対応

### 原則 IV（歴史的正確性と出典明記）
- `aiGenerated` はデータから削除するが、`<AiNotice>` コンポーネントは UI に維持
- Notion データベースを人的レビュー付き SSOT として使用
- 仕様書はデータ実装前の人的レビュー・承認を要求（US-6）

### 原則 V（パフォーマンスと継続的改善）
- 仮想化不要（領土あたりのイベント数は約 3〜20 件）
- 分類計算に `useMemo` を使用
- 既存のプリフェッチ/キャッシュ戦略を維持
